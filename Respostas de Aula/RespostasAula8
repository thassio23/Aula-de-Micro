Data: 26/04/2017
Thássio Gabriel Farias dos Santos
1. Escreva um código em C que pisca os LEDs ininterruptamente.

#include <msp430g2553.h>

int main(void) {
  volatile int i;
 
  WDTCTL = WDTPW | WDTHOLD;
  P1DIR =  BIT6 + BIT0;
  P1OUT =  BIT6 + BIT0;
   
  for (;;) {

    P1OUT ^=  BIT6 + BIT0;

    for (i = 0; i < 0x1000; i++);
  }
  
  }
  
2. Escreva um código em C que pisca os LEDs ininterruptamente. No ciclo que pisca os LEDs, o tempo que os LEDs ficam ligados deve ser duas vezes maior do que o tempo que eles ficam desligados.

#include <msp430g2553.h>
#define BTN BIT2
int main(void) {
  volatile int i,j;
  
  WDTCTL = WDTPW | WDTHOLD;
  P1DIR =  BIT6 + BIT0;
  P1OUT = 0;
  i = 0;
  j = 0;
  for (;;) {
     
  j = i*2;
    
    P1OUT ^=  BIT6 + BIT0;
    for (i = 0; i < j ; i++);
    P1OUT ^=  BIT6 + BIT0;
    for (i = 0; i < 0x1000 ; i++);
    P1OUT ^=  BIT6 + BIT0;
    for (i = 0; i < j ; i++);
    P1OUT ^=  BIT6 + BIT0;
    for (i = 0; i < 0x1000 ; i++);
     
    
  }
  
  }
  
3. Escreva um código em C que acende os LEDs quando o botão é pressionado.


#include <msp430g2553.h>
#define BTN BIT2
int main(void) {
  volatile int i,j;
  
  WDTCTL = WDTPW | WDTHOLD;
  P1DIR =  BIT6 + BIT0;
  P1OUT = 0;
  i = 0;
  for (;;) {
     
     
     if((P1IN & BTN) == BTN){
    P1OUT =  BIT6 + BIT0;
    }
     else P1OUT &=~(BIT6 + BIT0);
     
    
  }
  
  }

4. Escreva um código em C que pisca os LEDs ininterruptamente somente se o botão for pressionado.

#include <msp430g2553.h>
#define BTN BIT2
int main(void) {
  volatile int i,j;
  
  WDTCTL = WDTPW | WDTHOLD;
  P1DIR =  BIT6 + BIT0;
  P1OUT = 0;
  i = 0;
  for (;;) {
     
     
     if((P1IN & BTN) == BTN){
    P1OUT ^=  BIT6 + BIT0;
     for(i = 0; i< 0x1000; i++);
    }
     else P1OUT &=~(BIT6 + BIT0);
     
    
  }
  
  }

5. Escreva um código em C que acende os LEDs quando o botão é pressionado. Deixe o MSP430 em modo de baixo consumo, e habilite a interrupção do botão.

#include "msp430g2231.h"  
  
void main(void)
{
  
  WDTCTL = WDTPW + WDTHOLD;     // Stop WDT  
  CCTL0 = CCIE;                             // CCR0 interrupt enabled
  TACTL = TASSEL_2 + MC_1 + ID_3;           // SMCLK/8, upmode
  CCR0 =  10000;                     // 12.5 Hz   
  P1OUT &= 0x00;               // Shut down everything
  P1DIR &= 0x00;               
  P1DIR |= BIT0 + BIT6;            // P1.0 and P1.6 pins output the rest are input 
  P1REN |= BIT3;                   // Enable internal pull-up/down resistors
  P1OUT |= BIT3;                   //Select pull-up mode for P1.3
  P1IE |= BIT3;                       // P1.3 interrupt enabled
  P1IES |= BIT3;                     // P1.3 Hi/lo edge
  P1IFG &= ~BIT3;                  // P1.3 IFG cleared
  _BIS_SR(CPUOFF + GIE);          // Enter LPM0 w/ interrupt 
  while(1)                          //Loop forever, we work with interrupts!
  {}
} 

// Port 1 interrupt service routine
#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{ 
   int i;
   P1OUT ^= BIT6;                      // Toggle P1.6
   for(i = 0; i< 0x9000; i++);
   P1OUT ^= BIT6; 
   P1IFG &= ~BIT3;                     // P1.3 IFG cleared 
   
}
