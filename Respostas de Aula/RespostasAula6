Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	unsigned int Raiz_Quadrada(unsigned int S)

	{
	    float x[1000];
	    float a;
        int n;

        n == 0;
	    x[0] = S/2;


        for(n=0;n<1000;n++){

                x[n+1] = (x[n] + (S/x[n]))/2;
        }
        a = x[1000];
        return a;
	}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

Raiz_Quadrada:
        
	MOV.W numero,R6 ; VALOR DE ENTRADA
        MOV.W #0,R10                 
        MOV.W #0,R14                 
        MOV.W #20,R15                 
        MOV.W R6,R7
        MOV.W R6,R8
        MOV.W R6,R9
        RRA.w R8
        JMP divisao

divisao:
        ADD.W #1,R14
        SUB.W R8,R9
        ADD.W #1, R10
        CMP R9,R8
        jl divisao
        jeq final_divisao
        jne fim
final_divisao:
        ADD.W #1,R10
        
fim:    
        MOV.W R8,R11
        ADD.W R10,R11
        RRA.W R11
        MOV.W R11,R8
        CMP #3,R14
        jne divisao
	MOV.W R8,R15

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int Potencia(int x, int N)
	{
        if(N <= 1){
        return x;
		}
        if(N ==0){
        return 0;
        }
		return x*Potencia(x, --N);
	}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.

funcPOTENCIA:
         
         MOV.W #5,R15 ; VALOR DE ENTRADA
         MOV.W #4,R14 ; VALOR DE ENTRADA
         MOV.W #1, R7
         MOV.W R15, R10
         MOV.W #1,R9
         MOV.W R15,R5
         MOV.W R5,R8
         MOV.W R14, R6

MULTIPLICACAO:
         CMP R7, R5
         JEQ POTENCIA
         ADD.W #1,R7
         ADD.W R8,R10
         jmp MULTIPLICACAO

POTENCIA:
        
        MOV.W R10,R5
        MOV.W #0,R10
        ADD.W #1,R9
        CMP R14,R9
        MOV.W #0,R7
        JNE MULTIPLICACAO
        MOV.W R5, R15

3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.
	
	MOV.W #8,R6 ;valores de entrada
        MOV.W #3,R8 ;valores de entrada
        
        MOV.W #0,R10                 
        MOV.W #0,R14     
        MOV.W #8,R6
        MOV.W R6,R7
        MOV.W R6,R9
        JMP divisao

divisao:
        ADD.W #1,R14
        SUB.W R8,R9
        ADD.W #1, R10
        CMP R9,R8
        jl divisao
        jeq final_divisao
        jne fim
final_divisao:
        ADD.W #1,R10
        
fim:    
        MOV.W R10,R15
4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

        MOV.W #8,R6 ;valores de entrada
        MOV.W #5,R8 ;valores de entrada
        
        MOV.W #0,R10                 
        MOV.W #0,R14     
        MOV.W #8,R6
        MOV.W R6,R7
        MOV.W R6,R9
        JMP divisao

divisao:
        ADD.W #1,R14
        SUB.W R8,R9
        ADD.W #1, R10
        CMP R9,R8
        jl divisao
        jeq final_divisao
        jne fim
final_divisao:
        ADD.W #1,R10
        MOV.W #0,R9
        
fim:    
        MOV.W R9,R15
5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x)
	{   int i;
	    int m;
	    for(i = 2; i<10;i++){
        if(x%i == 0){
            m++;
        }
	    }
	    if( m == 0){
        return 1;
	    }
	    if(x < 10 && m == 1){
            return 1;
	    }
	    if(x < 10 && m > 1){
	    return 0;}
	    if(m != 0 && x>=10){
        return 0;
	    }
	}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n)
	{
	    unsigned long long i;
	    unsigned long long j;
	    unsigned long long k;
	    unsigned long long l;

	    k = n;
	    l = n;

	if (n == 0){
	return 1;
	}
	    for(i = 1; n > 1; n--){
        if(n%2 == 0){
            i *= n;
        }
        }

        for(j = 1; k > 1; k--){
        if(k%2 == 1){
            j *= k;
        }
        }
        if(l%2 == 1){
            return j;
        }
        if(l%2 == 0){
            return i;
        }
	}

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
int ExpTaylor(double x){
    int i,j,z,numero;
    double recebe;
    double b;
    double xelv[20];
    double nfat[20];
    b = x;
    numero = 1;
    recebe = 0;
    xelv[0]=1;
    xelv[1]= x;
    nfat[0]=1;
    for(i = 0;i < 10; i++){
        x = x * b;
        xelv[i+2] = x;
    }
  for(j=1; j<=9; ++j)
        {
            numero *= j;
            nfat[j] = numero;
        }
  for(z=0;z < 10; z++){
    recebe = recebe + (xelv[z]/nfat[z]);
  }
  return recebe;
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

    int Palindromo(int vetor[ ], int tamanho){
    int i,j;
    int m;
    int confere;
    int normal[tamanho];
    int inverso[tamanho];
    confere = 0;
    m = tamanho - 1;
    for(i = 0;i < tamanho;i++){
    normal[i]=vetor[i];
    inverso[m-i] = vetor[i];
    }
    for(j = 0; j <tamanho ;j++){
    if (normal[j] == inverso[j]){
        confere++;
    }
}
    if (confere == tamanho){
        return 1;
    }else return 0;
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.
