#include <msp430g2553.h>

void atraso(volatile unsigned int x)
{
  TACCR0 = 100-1;
  TACTL |= TACLR;
  TACTL = TASSEL_2 + ID_0 + MC_1;
  while(x>0)
  {
    x--;
    while((TACTL & TAIFG) == 0);
    TACTL &=~TAIFG;
  }
  TACTL = MC_0;
}

int regrade3(unsigned int x)
{
  int pwm;
  pwm = (x*17/1023) + 5;
  
  
  return pwm;
}
#define LED0 BIT0 

#define LED1 BIT6 

unsigned int value=0;

void ConfigureAdc(void)

{

   /* Configure ADC Channel */

   ADC10CTL1 = INCH_5 + ADC10DIV_3 ; // Channel 5, ADC10CLK/4

   ADC10CTL0 = SREF_0 + ADC10SHT_3 + ADC10ON + ADC10IE; //Vcc & Vss as reference

   ADC10AE0 |= BIT5; //P1.5 ADC option

}



void main(void)

{
  unsigned int ValorRecebido;
                int ValorAtraso;

   WDTCTL = WDTPW + WDTHOLD; // Stop WDT

   BCSCTL1 = CALBC1_1MHZ; // Set range

   DCOCTL = CALDCO_1MHZ;

   BCSCTL2 &= ~(DIVS_3); // SMCLK = DCO = 1MHz

   P1DIR |= LED0 + LED1 + BIT4;

   P1SEL |= BIT5; //ADC Input pin P1.5

   P1OUT &= ~(LED0 + LED1);


   ConfigureAdc();
   
   P1REN |= BIT3;                   // Enable internal pull-up/down resistors
  P1OUT |= BIT3;                   //Select pull-up mode for P1.3
  P1IE |= BIT3;                       // P1.3 interrupt enabled
  P1IES |= BIT3;                     // P1.3 Hi/lo edge
  P1IFG &= ~BIT3;                  // P1.3 IFG cleared

   __enable_interrupt(); // Enable interrupts.


 while(1)

   {

      __delay_cycles(1000); // Wait for ADC Ref to settle

      ADC10CTL0 |= ENC + ADC10SC; // Sampling and conversion start

      __bis_SR_register(CPUOFF + GIE); // LPM0 with interrupts enabled

      value = ADC10MEM;

atraso(10);				
			ADC10CTL0 |= ENC + ADC10SC;			
			ValorRecebido = ADC10MEM;
                         ValorAtraso = 190;
                         atraso(ValorAtraso);
                         P1OUT |= BIT4;
                         ValorAtraso = regrade3(ValorRecebido);
                         atraso(ValorAtraso);
                         P1OUT ^= BIT4;

   }
}


// ADC10 interrupt service routine

#pragma vector=ADC10_VECTOR

__interrupt void ADC10_ISR (void)

{

   __bic_SR_register_on_exit(LPM3_bits); // Return to active mode

}

#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{    
   P1OUT ^= BIT6;                      // Toggle P1.6
   P1IFG &= ~BIT3;                     // P1.3 IFG cleared 
}
